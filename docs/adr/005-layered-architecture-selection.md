## アーキテクチャ選択（層状アーキテクチャ採用）

<b>日時: 2025-06-24</b>

### ステータス (Status)
承認済み (accepted)

### 背景 (Context)
要件定義書を分析した結果、このプロダクトに最適なアーキテクチャパターンを選択する必要があった。プロダクト特性として以下が明らかになった：

- **ビジネスロジック**: シンプル（トランザクション署名のみ）
- **ドメイン**: 単一（Ethereum署名）
- **データ永続化**: なし（ファイル読み込みのみ）
- **外部システム**: なし（オフライン前提）
- **インターフェース**: CLI単一
- **開発規模**: 個人開発、短期（コーディングテスト）

さらに要件定義書1.4で「過剰設計を避け、定義された要件の品質を最大化」が明確に指示されていた。

### 決定事項 (Decision)
層状アーキテクチャ（Layered Architecture）を採用する。

具体的な層構成：
```
┌─────────────────────────────────────────────┐
│                CLI層 (cli/)        　  　    │  プレゼンテーション層
│             UI・入出力制御                    │  commander.js
├─────────────────────────────────────────────┤
│            アプリケーション層 (core/)          │  ビジネスロジック層
│         ワークフロー制御・調整             　   │  TypeScript, viem
├─────────────────────────────────────────────┤
│              ドメイン層 (types/) 　           │  ドメインモデル層
│         ビジネスルール・データモデル     　      │  Zod, TypeScript
├─────────────────────────────────────────────┤
│           インフラストラクチャ層 (utils/)   　  │  インフラ層
│         横断的関心事・外部リソース     　  　    │  Node.js FS, Logger
└─────────────────────────────────────────────┘
```

各層の責務：
1. **CLI Layer**: ユーザーインターフェース、入出力制御
2. **Application Layer**: ビジネスロジック調整、ワークフロー制御
3. **Domain Layer**: ビジネスルール、データモデル（純粋）
4. **Infrastructure Layer**: 横断的関心事、外部リソースアクセス（純粋）

実装スタイル：関数ベースアプローチを採用（過剰設計を避けるため）

### 比較した選択肢 (Options Considered)

#### 1. クリーンアーキテクチャ + DDD
**理由で不採用:**
- **過剰設計**: 要件1.4に反する
- **複雑度不一致**: 単純なドメインに過度な抽象化
- **開発効率低下**: 短期プロジェクトに不向き
- **保守性悪化**: 小規模チームには複雑すぎる

#### 2. ヘキサゴナルアーキテクチャ
**理由で不採用:**
- **外部システム連携なし**: アーキテクチャの主要メリットが活用不可
- **複雑度過剰**: ポート・アダプターパターンが不要
- **学習コスト**: 短期開発に見合わない

#### 3. MVC
**理由で不採用:**
- **CLIアプリには不自然**: Webアプリケーション向けパターン
- **View層が不明確**: コマンドライン出力にViewという概念は過剰
- **部分適用は可能だが**: より適切な選択肢が存在

#### 4. 層状アーキテクチャ（採用）
**採用理由:**
- **適切な複雑度**: シンプルながら構造化
- **要件適合**: 「過剰設計を避け」に準拠
- **保守性確保**: 関心事の分離を実現
- **テスト容易性**: 各層の独立テスト可能
- **学習コスト低**: 一般的で理解しやすい

### 結果 (Consequences)

#### より簡単になること
- **理解しやすさ**: 新規開発者でも直感的に理解可能
- **保守性**: 各層の責務が明確で変更が容易
- **テスト性**: 依存関係が明確で単体テストが書きやすい
- **開発速度**: 過剰な抽象化がないため実装が迅速
- **デバッグ**: シンプルな依存関係でトラブルシューティングが容易

#### より困難になること
- **拡張性の制限**: 将来的に複雑なドメインロジックが必要になった場合のリファクタリング
- **厳密なドメイン境界**: DDDのような厳密なドメイン分離は実現困難
- **外部システム連携**: 将来的に複数の外部システムと連携する場合の設計変更
- **マイクロサービス化**: 分散システムへの発展は大幅な再設計が必要

ただし、これらの「困難になること」は要件定義書1.4「将来的な機能拡張は一切考慮しない」により、意図的に受け入れる制約である。 