# ADR-001: CI/CD Pipeline Simplification

**日時: 2024-06-17**

## ステータス (Status)
accepted

## 背景 (Context)

eth-offline-signerプロジェクトは、コーディングテスト用途のシンプルなCLIツールとして設計されている。CI/CDパイプラインの技術選定において、複数のアプローチを比較検討した。

### プロジェクト特性
- **目的**: コーディングテスト用途（短期開発サイクル）
- **スコープ**: 単一機能（EIP-1559オフライン署名）
- **チーム規模**: 個人開発
- **運用要件**: 必要最小限の品質保証

この特性を踏まえ、適切なCI/CD構成を選定する必要があった。

## 決定事項 (Decision)

以下の5つのジョブで構成されたシンプルかつ効果的なCI/CDパイプラインを採用する：

### 1. コード品質チェック
- Biome lintによるコード品質検証
- TypeScript型チェックによる静的解析

### 2. テスト実行
- クロスプラットフォーム互換性テスト（3 OS × 3 Node.jsバージョン）
- テストカバレッジ収集と外部サービス連携
- 適切なアーティファクト保持期間設定

### 3. セキュリティ監査
- 依存関係の脆弱性チェック
- moderate-levelでのCI失敗制御
- セキュリティ監査結果の保存

### 4. ビルドと検証
- アプリケーションビルドと成果物検証
- CLI機能の動作確認テスト
- ビルドアーティファクトの管理

### 5. リリース自動化
- mainブランチ限定の自動リリース
- バージョン管理とリリースノート生成
- GitHub Release作成

### 品質ゲート設計
- 段階的な依存関係による実行制御
- セキュリティ監査失敗時のCI停止
- 実際のCLI機能テストによる動作保証

## 比較した選択肢 (Options Considered)

### 選択肢1: 最小構成（lint + test + buildのみ）
- **メリット**: 最高速度、最小リソース消費
- **デメリット**: セキュリティチェック不足、リリース自動化なし
- **判定**: 却下（品質保証が不十分）

### 選択肢2: 現在の構成（採用）
- **メリット**: 
  - **コードの品質に対する信頼**: Biome lintと9つの環境（3 OS × 3 Node.js）でのテストが品質の最低ラインを常に保証
  - **セキュリティに対する信頼**: 脆弱性のある依存関係がマージされることを防止、moderate-levelでのCI失敗により事前検出
  - **ビルド成果物に対する信頼**: CLI機能テスト（`--version`、`--help`、`sign`機能）により、npmに公開されるパッケージの動作を保証
  - **リリースプロセスに対する信頼**: 完全自動化によりヒューマンエラーを排除、バージョン管理とリリースノート生成の一貫性
  - **クロスプラットフォーム互換性に対する信頼**: Windows、macOS、Linuxでの動作保証、Node.js 18、20、22での互換性保証
  - **開発プロセスに対する信頼**: 段階的な依存関係による効率的な早期失敗、明確な失敗ポイント特定によるデバッグ時間最小化
- **デメリット**: 基本構成より実行時間が長い（全ジョブ完了まで15-20分必要）
- **判定**: 採用（品質と効率のバランスが最適）

### 選択肢3: 高度な監視・メトリクス構成（performance.yml + metrics.yml）
- **メリット**: 包括的なパフォーマンス監視、詳細なメトリクス収集
- **実際の問題**: 
  - Performance Monitoring Workflow（203行）の運用負荷が過大
  - Metrics Collection Workflow（208行）の維持コストが高い
  - 90日間のアーティファクト保持による不要なストレージ消費
  - 3 OS × 3 Node.jsバージョンのマトリックステストによる実行時間の増大
  - プロジェクト規模との不整合による過剰設計
- **削除理由**:
  - **performance.yml**: コーディングテスト用途では機能性検証が最優先であり、パフォーマンス最適化は二の次。個人の実験的プロジェクトレベルでは設定の手間に対してメリットが限定的
  - **metrics.yml**: 初期段階のプロトタイプでは品質やパフォーマンスより素早い形作りが最優先。単一開発者で全体像を把握できている状況では詳細なメトリクス収集は過剰装備
- **判定**: 却下（運用負荷とコストが見合わない）

### 選択肢4: 基本構成 + パフォーマンス監視のみ
- **メリット**: 基本品質保証 + 限定的な監視
- **デメリット**: セキュリティ監査不足、リリース自動化なし
- **判定**: 却下（セキュリティ要件を満たさない）

### 選択肢5: マトリックステスト削減構成
- **メリット**: CI実行時間の大幅短縮
- **デメリット**: Node.js/OS互換性の検証不足
- **判定**: 保留（将来的な最適化候補）

## 結果 (Consequences)

### プラスの影響
1. **開発効率の最適化**
   - 適切なCI実行時間（平均15-20分）
   - 明確な失敗ポイントの特定
   - 効率的なデバッグプロセス

2. **品質保証の確実性**
   - 選択肢2で定義した6つの信頼要素の実現
   - 段階的な品質ゲート（lint → test → security → build → release）による多層防御

3. **運用の自動化**
   - 完全自動リリースプロセス
   - 包括的なリリースノート生成
   - 適切なアーティファクト管理（7-30日保持）

4. **プロジェクト適合性**
   - コーディングテスト用途に最適化された複雑度
   - 個人開発プロジェクトとして適切なスケール
   - 維持可能な設定ファイル構成

### マイナスの影響
1. **実行時間のトレードオフ**
   - マトリックステストによる実行時間増加
   - 全ジョブ完了まで15-20分必要

2. **リソース使用量**
   - 9つの並列ジョブ実行（3 OS × 3 Node.js）
   - GitHub Actionsの実行時間消費

### 軽減策と最適化
1. **効率的なキャッシュ戦略**
   - pnpmストアキャッシュによる依存関係インストール高速化
   - Node.js環境の再利用

2. **段階的実行**
   - 依存関係による段階的ジョブ実行
   - 早期失敗による無駄なリソース消費の回避

3. **将来的な最適化余地**
   - 必要に応じたマトリックス縮小
   - 条件付きジョブ実行の導入
